<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>test</title>
    <link href="/Ouyang/2020/08/08/test/"/>
    <url>/Ouyang/2020/08/08/test/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>解决Default Activity not found</title>
    <link href="/Ouyang/2020/07/06/%E8%A7%A3%E5%86%B3Default-Activity-not-found/"/>
    <url>/Ouyang/2020/07/06/%E8%A7%A3%E5%86%B3Default-Activity-not-found/</url>
    
    <content type="html"><![CDATA[<p>今天把Android studio开发工具版本升级到4.0后，拉取项目工程代码运行的时候一直报这个错误：Error running :<br>Default Activity not found<br>网上各种方法，什么重启AS啊，清缓存啊，啥都不管用。最后的解决方案是手动把位于C盘目录下的C:\Users\aaron.AndroidStudio4.0\system\caches文件夹删掉，再重启AS问题才得以解决。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在onCreate里面显示PopWindow会发生什么?</title>
    <link href="/Ouyang/2020/05/28/%E5%9C%A8onCreate%E9%87%8C%E9%9D%A2%E6%98%BE%E7%A4%BAPopWindow%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/"/>
    <url>/Ouyang/2020/05/28/%E5%9C%A8onCreate%E9%87%8C%E9%9D%A2%E6%98%BE%E7%A4%BAPopWindow%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h4><span id="1在oncreate方法里面调用popupwindow的showasdropdown或者showatlocation会发生什么">1.在onCreate()方法里面调用PopupWindow的showAsDropDown或者showAtLocation会发生什么？</span></h4><p>​       我们来实践下，在onCreate里面写入如下代码</p><pre><code class="java">   @Override   protected void onCreate(Bundle savedInstanceState){   super.onCreate(savedInstanceState);   setContentView(R.layout.activity_main);   Toolbar toolbar = findViewById(R.id.toolbar);   setSupportActionBar(toolbar);   mTextView = findViewById(R.id.hello);   FloatingActionButton fab = findViewById(R.id.fab);   fab.setOnClickListener(new View.OnClickListener()   {      @Override      public void onClick(View view)      {         Snackbar.make(view, &quot;Replace with your own action&quot;, Snackbar.LENGTH_LONG)               .setAction(&quot;Action&quot;, null).show();      }   });   mPopupWindow = new PopupWindow(this.getBaseContext());   mPopupWindow.setContentView(new View(this.getBaseContext()));   mPopupWindow.showAtLocation(mTextView, 0, 0, 0);}</code></pre><p>运行跑下出现如下异常，wtf</p><p><img src="/Ouyang/images/popWindow/1.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p><p>这是什么鬼？why？</p><h4><span id="2为啥会发生这个异常">2.为啥会发生这个异常？</span></h4><p>我们断点进去一步一步顺藤摸瓜，最终在ViewRootImpl的setView方法里面找到这个异常</p><p><img src="/Ouyang/images/popWindow/2.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p><p><img src="/Ouyang/images/popWindow/3.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p><p>也就是说res这个鬼东西命中了ADD_BAD_SUBWINDOW_TOKEN，那这个res是从哪里来的呢？关键代码如下</p><pre><code class="java">  res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,                            getHostVisibility(), mDisplay.getDisplayId(), mWinFrame,                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,                            mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel);</code></pre><p>它调用了Session里面的一个addToDisplay方法，最终会走到WMS的addWindow方法</p><pre><code class="java">public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,        int viewVisibility, int displayId, Rect outFrame, Rect outContentInsets,        Rect outStableInsets, Rect outOutsets,        DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel) {    return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outFrame,            outContentInsets, outStableInsets, outOutsets, outDisplayCutout, outInputChannel);}</code></pre><p>我们来看下wms这个addWindow方法是干嘛的，贴代码如下：</p><pre><code class="java">    public int addWindow(Session session, IWindow client, int seq,            WindowManager.LayoutParams attrs, int viewVisibility, int displayId,            Rect outContentInsets, Rect outStableInsets, Rect outOutsets,            InputChannel outInputChannel) {        int[] appOp = new int[1];//  权限检测，有兴趣的可以自己点进去看看        int res = mPolicy.checkAddPermission(attrs, appOp);        if (res != WindowManagerGlobal.ADD_OKAY) {            return res;        }        ...        synchronized(mWindowMap) {         /** final WindowState win = new WindowState(this, session, client,    token, parentWindow,             mWindowMap.put(client.asBinder(), win);              win = mWindow = new W(this);             public ViewRootImpl(Context context, Display display) {                ...                mWindow = new W(this);                ...             }        */          appOp[0], seq, attrs, viewVisibility, session.mUid,          session.mCanAddInternalSystemWindow);            //异常1            if (mWindowMap.containsKey(client.asBinder())) {                Slog.w(TAG_WM, &quot;Window &quot; + client + &quot; is already added&quot;);                return WindowManagerGlobal.ADD_DUPLICATE_ADD;            }            /**              window类型type:              type表示Window的类型，Window有三种类型，分别是应用Window，子              Window和系统Window。              应用类Window对应着一个Activity。子Window不能单独存在，它需要附属在特定的父Window中，比如Dialog就是一个子Window。系统Window              是需要声明权限才能创建的Window，比如Toast和系统状态栏这些都是系统Window。              Window是分层的，每个Window都有对应的z-ordered，层级大的会覆盖    在层级小的Window上。在三类Window中，应用Window的层级范围是1~99，子              Window的层级范围是1000~1999，系统Window的层级范围是2000~2999。很显然系统Window的层级是最大的，而且系统层级有很多值，一              般我们可以选用TYPE_SYSTEM_ERROR或者TYPE_SYSTEM_OVERLAY，另外重要的是要记得在清单文件中声明权限。            */            if (type &gt;= FIRST_SUB_WINDOW &amp;&amp; type &lt;= LAST_SUB_WINDOW) {                parentWindow = windowForClientLocked(null, attrs.token, false);                if (parentWindow == null) {                    Slog.w(TAG_WM, &quot;Attempted to add window with token that is not a window: &quot;                          + attrs.token + &quot;.  Aborting.&quot;);                    return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;                }                //子Window                if (parentWindow.mAttrs.type &gt;= FIRST_SUB_WINDOW                        &amp;&amp; parentWindow.mAttrs.type &lt;= LAST_SUB_WINDOW) {                    Slog.w(TAG_WM, &quot;Attempted to add window with token that is a sub-window: &quot;                            + attrs.token + &quot;.  Aborting.&quot;);                    return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;                }            }            if (type == TYPE_PRIVATE_PRESENTATION &amp;&amp; !displayContent.isPrivate()) {                Slog.w(TAG_WM, &quot;Attempted to add private presentation window to a non-private display.  Aborting.&quot;);                return WindowManagerGlobal.ADD_PERMISSION_DENIED;            }           ...            if (token == null) {               //应用Window                if (rootType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) {                    Slog.w(TAG_WM, &quot;Attempted to add application window with unknown token &quot;                          + attrs.token + &quot;.  Aborting.&quot;);                    return WindowManagerGlobal.ADD_BAD_APP_TOKEN;                }                if (rootType == TYPE_WALLPAPER) {                    Slog.w(TAG_WM, &quot;Attempted to add wallpaper window with unknown token &quot;                          + attrs.token + &quot;.  Aborting.&quot;);                    return WindowManagerGlobal.ADD_BAD_APP_TOKEN;                }               ....                if (rootType == TYPE_ACCESSIBILITY_OVERLAY) {                    Slog.w(TAG_WM, &quot;Attempted to add Accessibility overlay window with unknown token &quot;                            + attrs.token + &quot;.  Aborting.&quot;);                    return WindowManagerGlobal.ADD_BAD_APP_TOKEN;                }                if (type == TYPE_TOAST) {                    // Apps targeting SDK above N MR1 cannot arbitrary add toast windows.                    if (doesAddToastWindowRequireToken(attrs.packageName, callingUid,                            parentWindow)) {                        Slog.w(TAG_WM, &quot;Attempted to add a toast window with unknown token &quot;                                + attrs.token + &quot;.  Aborting.&quot;);                        return WindowManagerGlobal.ADD_BAD_APP_TOKEN;                    }                }             ...            if (type == TYPE_TOAST) {                if (!getDefaultDisplayContentLocked().canAddToastWindowForUid(callingUid)) {                    Slog.w(TAG_WM, &quot;Adding more than one toast window for UID at a time.&quot;);                    return WindowManagerGlobal.ADD_DUPLICATE_ADD;                }                ...            }            // From now on, no exceptions or errors allowed!            res = WindowManagerGlobal.ADD_OKAY;            if (mCurrentFocus == null) {                mWinAddedSinceNullFocus.add(win);            }            ...            win.attach();            mWindowMap.put(client.asBinder(), win);           ...            boolean imMayMove = true;            win.mToken.addWindow(win);            ...        return res;    }</code></pre><p>在上面的addWindow方法里面我们看到当type在1000-1999时候，如果parentWindow为空会返回WindowManagerGlobal的ADD_BAD_SUBWINDOW_TOKEN, 那为啥PopWindow的type是在这个范围呢？我们查看PopWindow源码的createPopupLayoutParams方法的时候发现其赋值type的地方</p><pre><code class="java">protected final WindowManager.LayoutParams createPopupLayoutParams(IBinder token) {    final WindowManager.LayoutParams p = new WindowManager.LayoutParams();    // These gravity settings put the view at the top left corner of the    // screen. The view is then positioned to the appropriate location by    // setting the x and y offsets to match the anchor&#39;s bottom-left    // corner.    p.gravity = computeGravity();    p.flags = computeFlags(p.flags);    p.type = mWindowLayoutType; // 就是这个变量！！    p.token = token;    p.softInputMode = mSoftInputMode;    p.windowAnimations = computeAnimationResource();    if (mBackground != null) {        p.format = mBackground.getOpacity();    } else {        p.format = PixelFormat.TRANSLUCENT;    }  ....}</code></pre><p>我们看到里面有个全局变量mWindowLayoutType，这个初始值为</p><pre><code class="java">private int mWindowLayoutType = WindowManager.LayoutParams.TYPE_APPLICATION_PANEL;</code></pre><pre><code class="java">public static final int TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW = 1000;</code></pre><p>所以看到PopWindow的type就是1000。那为什么parentWindow获取空呢？我们继续跟踪这个方法</p><pre><code class="java">parentWindow = windowForClientLocked(null, attrs.token, false);</code></pre><pre><code class="java">final WindowState windowForClientLocked(Session session, IBinder client, boolean throwOnError) {    WindowState win = mWindowMap.get(client);    if (localLOGV) Slog.v(TAG_WM, &quot;Looking up client &quot; + client + &quot;: &quot; + win);    if (win == null) {        if (throwOnError) {            throw new IllegalArgumentException(                    &quot;Requested window &quot; + client + &quot; does not exist&quot;);        }        Slog.w(TAG_WM, &quot;Failed looking up window callers=&quot; + Debug.getCallers(3));        return null;    }    if (session != null &amp;&amp; win.mSession != session) {        if (throwOnError) {            throw new IllegalArgumentException(&quot;Requested window &quot; + client + &quot; is in session &quot;                    + win.mSession + &quot;, not &quot; + session);        }        Slog.w(TAG_WM, &quot;Failed looking up window callers=&quot; + Debug.getCallers(3));        return null;    }    return win;}</code></pre><p>上面代码传入的attr.token为空了 导致获取win直接为空，最后直接返回空了命中！那attr.token为啥为空呢？</p><p>还记得我们showAtLocation吗，里面有个token传参，间接导致PopWindow里面的WindowManager.LayoutParams中的token参数为空，最后直接命中！原来一切根源都是这个外部传参token为空！那最后来追究为啥在onCreate()方法里面 这个token为啥空了。</p><h4><span id="3根源mwindowtoken为空">3.根源mWindowToken为空</span></h4><pre><code class="java">public void showAtLocation(View parent, int gravity, int x, int y) {    mParentRootView = new WeakReference&lt;&gt;(parent.getRootView());    showAtLocation(parent.getWindowToken(), gravity, x, y); // 此处的parent.getWindowToken()为空了}</code></pre><p>断点查看到parent的View的getWindowToken方法里面的mAttachInfo为空了，那我们再继续查询mAttachInfo为啥空了，mAttachInfo在哪里赋值的？我们全局搜索下在View的dispatchAttachedToWindow方法里面赋值的，原来这个mAttachInfo是在ViewRootImpl初始化的时候赋值的</p><pre><code class="java">public ViewRootImpl(Context context, Display display) {    mContext = context;    mWindowSession = WindowManagerGlobal.getWindowSession();    mDisplay = display;    .......    mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this, context); // 看到没，就是这儿！！    .....}</code></pre><p>我们知道ViewRootImpl是在WindowManagerGlobal的addView时候添加进来的，而addView是在ActivityThread的handleResumeActivity方法添加的。</p><pre><code class="java">@Overridepublic void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,        String reason) {    // If we are getting ready to gc after going to the background, well    // we are back active so skip it.    unscheduleGcIdler();    mSomeActivitiesChanged = true;    // TODO Push resumeArgs into the activity for consideration    final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);     // performResumeActivity会走到Activity的onResume方法    if (r == null) {        // We didn&#39;t actually resume the activity, so skipping any follow-up actions.        return;    }    final Activity a = r.activity;    .........        if (a.mVisibleFromClient) {            if (!a.mWindowAdded) {                a.mWindowAdded = true;                wm.addView(decor, l); // 就在此处添加View            } else {                // The activity will get a callback for this {@link LayoutParams} change                // earlier. However, at that time the decor will not be set (this is set                // in this method), so no action will be taken. This call ensures the                // callback occurs with the decor set.                a.onWindowAttributesChanged(l);            }        }    .........    .........}</code></pre><p>我们看到addView其实在performResumeActivity后才添加进来的，你在Activity的onCreate里面当然不会addView了。这下终于水落石出了！</p><p>最后总结下：</p><p>当我们在onCreate里面显示PopWindow的时候，由于还没把顶层View添加进来导致ViewRootImpl还没创建，最后mAttachInfo也为空，导致最终的mWindowToken也空了，最终引发我们崩溃的血案！</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>仪表盘自绘View</title>
    <link href="/Ouyang/2020/05/19/%E4%BB%AA%E8%A1%A8%E7%9B%98%E8%87%AA%E7%BB%98View/"/>
    <url>/Ouyang/2020/05/19/%E4%BB%AA%E8%A1%A8%E7%9B%98%E8%87%AA%E7%BB%98View/</url>
    
    <content type="html"><![CDATA[<p>主要介绍里面一些实现功能点的方法。</p><p>首先这个View主要涉及这几个技能点。</p><p>canvas几个技能点</p><ul><li>画布中心点平移</li><li>画布旋转</li><li>画布状态保存与恢复</li><li>画布画圆弧</li></ul><p>画笔Paint几个技能点</p><ul><li>画文字</li><li>画线</li></ul><p>渐变色</p><ul><li>SweepGradient</li></ul><p>动画</p><ul><li>ValueAnimator</li></ul><p>………………………………………………………………………………………………………………………………….</p><ol><li>画布中心点平移 canvas.translate(float dx, float dy), 我们知道画布中心点（0, 0）默认在左上角, 我们把中心点通过canvas.translate(mWidth / 2, mHeight)平移到画布中心，这样更好的算坐标。这样中心点就到半圆弧中心处。<br><img src="/Ouyang/images/yibiao/1.png" srcset="/Ouyang/img/loading.gif" alt="alt"></li><li>画布旋转canvas.rotate(float a), 这里的a值表示度数，a &gt; 0表示以画布中心顺时针旋转a度，反之，a &lt; 0表示逆时针旋转a度；canvas.rotate(float a, float px, float py),以中心坐标点（px, py）进行旋转a度。</li><li>canvas.save 将画布之前的状态先保存起来，之后画布可以进行任意操作，代码进行到canvas.restore后又可以恢复到画布原始的状态。</li><li>利用canvas.drawArc(RectF oval, float startAngle, float sweepAngle, Boolean useCenter, Paint paint) 画圆弧，参数oval为以圆弧中心点外切圆的矩形，startAngle为扫描的起始角度，大于0表示顺时针旋转startAngle，小于0逆时针旋转，这个参数的作用是设置圆弧是从哪个角度来顺时针绘画的。sweepAngle为扫过的角度。useCenter<br>是否经过圆中心点。</li><li>画文字，canvas.drawText(String text, float x, float baseLineY, Paint paint)</li><li>画线，canvas.drawLine(float startX, float startY, float stopX, float stopY, Paint paint)</li><li>渐变色效果采用SweepGradient</li><li>动画ValueAnimator</li></ol><h5><span id="画外层圆弧"><strong>画外层圆弧</strong></span></h5><p>​          首先我们把坐标中心移动到半圆弧中心</p><p><img src="/Ouyang/images/yibiao/2.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p><p><img src="/Ouyang/images/yibiao/3.png" srcset="/Ouyang/img/loading.gif" alt="alt">          </p><p> 圆弧真正的半径其实是radius,我们可以通过看下方的草图得知：</p><p><img src="/Ouyang/images/yibiao/4.png" srcset="/Ouyang/img/loading.gif" alt="alt">  </p><p>   这里腾出的偏移量mOffset是为了放刻度值显示的，所以半径radius等于mRadius减去mOffset再减去画笔粗度的一半。rectFArc 是以半径radius外切矩形，扫描的起始角度从180度开始，顺时针扫描180就可以得到半圆弧了。</p><h5><span id="画内层圆弧"><strong>画内层圆弧</strong></span></h5><p>​         同理一样，画内层圆弧的不同点就是半径不一样   <img src="/Ouyang/images/yibiao/5.png" srcset="/Ouyang/img/loading.gif" alt="alt">  </p><h5><span id="画进度圆弧">画进度圆弧</span></h5><p><img src="/Ouyang/images/yibiao/6.png" srcset="/Ouyang/img/loading.gif" alt="alt">      </p><p>​      在这个函数，我们用一个变量mCurrentAngle代表当前进度角度，也就是扫过的角度，这个值怎么来的呢？后面会说明。</p><h5><span id="进度圆弧渐变色">进度圆弧渐变色</span></h5><p>​        做这个点卡了下，也是个稍微难点的地方，其实都知道就是给画笔设置Shader,但尝试了很多方法最后就是出不来效果，后来做出来的时候其实代码很简单。</p><p>​    首先，我们来了解下渐变色的知识，Android支持三种颜色渐变，LinearGradient（线性渐变） RadialGradient （径向渐变） SweepGradient（扫描渐变）。这三种渐变继承自android.graphics.Shader， Paint 类通过setShader支持渐变。</p><p> （1）线性渐变LinearGradient</p><p><img src="/Ouyang/images/yibiao/7.png" srcset="/Ouyang/img/loading.gif" alt="alt">  </p><p><img src="/Ouyang/images/yibiao/8.png" srcset="/Ouyang/img/loading.gif" alt="alt">  </p><ol><li><p>float x0, float y0, float x1, float y1 定义了起始点的和结束点的坐标。</p></li><li><p>int[] colors 颜色数组，在线性方向上渐变的颜色。</p></li><li><p>float[] positions 和上边的数组对应，取值[0..1]，表示每种颜色的在线性方向  上所占的百分比。可以为Null,为Null 是均匀分布。</p></li><li><p>Shader.TileMode tile 表示绘制完成，还有剩余空间的话的绘制模式。</p><p>第二个构造函数参数：</p></li><li><ol><li>float x0, float y0, float x1, float y1 定义了起始点的和结束点的坐标。</li><li>int color0, int color1, 开始颜色和结束的颜色</li><li>Shader.TileMode tile 表示绘制完成，还有剩余空间的话的绘制模式。  </li></ol><p>(2) 径向渐变RadialGradient</p><p>圆环的渐变，有两个构造函数    <img src="/Ouyang/images/yibiao/9.png" srcset="/Ouyang/img/loading.gif" alt="alt">  </p></li><li><p>float centerX, float centerY 渐变的中心点 圆心</p></li><li><p>float radius 渐变的半径</p></li><li><p>int[] colors 渐变颜色数组</p></li><li><p>float[] stops 和颜色数组对应， 每种颜色在渐变方向上所占的百分比取值[0, 1]</p></li><li><p>Shader.TileMode tileMode 表示绘制完成，还有剩余空间的话的绘制模式。</p></li></ol><p>​    <img src="/Ouyang/images/yibiao/10.png" srcset="/Ouyang/img/loading.gif" alt="alt">  </p><ol><li><p>float centerX, float centerY 渐变的中心点 圆心</p></li><li><p>float radius 渐变的半径</p></li><li><p>int centerColor, int edgeColor 中心点颜色和边缘颜色</p></li><li><p>Shader.TileMode tileMode 表示绘制完成，还有剩余空间的话的绘制模式</p><p>(3) 扫描渐变SweepGradient</p><p>扫描渐变是和角度有关的渐变。以某一点为圆心，随着角度的大小发生渐变。</p></li></ol><p><img src="/Ouyang/images/yibiao/11.png" srcset="/Ouyang/img/loading.gif" alt="alt">  </p><ol><li>float cx, float cy 中心点坐标</li><li>int[] colors 颜色数组</li><li>float[] positions 数组颜色在渐变方向上所占的百分比</li></ol><p><img src="/Ouyang/images/yibiao/12.png" srcset="/Ouyang/img/loading.gif" alt="alt">  </p><p>  1.float cx, float cy 中心点坐标</p><p>  2.int color0, int color1 开始颜色 结束颜色</p><p>   我们仪表盘的渐变色采用的就是扫描渐变，起初我采用的是第二个构造函数，以为传入渐变的开始颜色值和结束的颜色值就行，后来发现达不到预期效果。原因应该是扫描的位置不对，SweepGradient这个扫描默认是三点钟方向开始顺时针旋转360，但是我通过进入矩阵matirx进行旋转它的扫描起始位置还是没达到预期效果，原因未知。后来采用引入参数数组positions的构造方法。具体代码如下：</p><p><img src="/Ouyang/images/yibiao/13.png" srcset="/Ouyang/img/loading.gif" alt="alt">  </p><p>​    positions的取值范围[0, 1]，由于步进圆弧终点位置不停的变化，这里我们采用传入数组postions参数进行设置，每一个position对应colors数组中每个颜色在360度中的相对位置，position取值范围为[0,1]，0和1都表示3点钟位置，0.25表示6点钟位置，0.5表示9点钟位置，0.75表示12点钟位置，这样根据当前扫过的角度mCurrentAngle算出终点position, 数组colors的长度必须和positions长度一致！！我们从180度开始，也就是9点钟方向。所以当前位置currentPosition = (mCurrentAngle + 180) / 360; 这样数组postions就为{0.5f, currentPosition}。</p><h5><span id="画刻度线及刻度值"><strong>画刻度线及刻度值</strong></span></h5><p>​       怎样画刻度线且都是均匀显示的呢？可能普通的做法就是寻找每个刻度线的坐标去画线，刚开始也想这样去计算某个刻度线坐标，但这样太复杂了。我们采用画布的保存、画布的旋转以及画布的恢复方法，再用画笔的画线方法就可以做到刻度线均匀分布。包括画指定的刻度值也是一样，如果用三角函数去算其坐标也比较复杂。而且绘制的时候会出现很难对准刻度线。</p><p>截取部分代码如下： <img src="/Ouyang/images/yibiao/14.png" srcset="/Ouyang/img/loading.gif" alt="alt">  </p><p><img src="/Ouyang/images/yibiao/15.png" srcset="/Ouyang/img/loading.gif" alt="alt">  </p><p>每一次循环画刻度线的时候，将画布先保存起来，这样在下一次循环的时候画布又重新回到最初的状态。100格，顺时针旋转的角度为 （float）180/100 * i ;注意这里角度为浮点型，之前做的时候没注意到导致画的刻度不够 =-=；在i = 0，20，40，60，80，100 需要画刻度值。  </p><p>​    这里画刻度值采用画布中心点平移以及旋转的方法来做。我们以画20为例子。如下图准备画刻度值的时候，我们的画布由于在画刻度线的时候已经顺时针旋转到坐标系（x2, y2）了，这个时候将y2平移offset偏移量到y3，此时我们的坐标系变成(x2, y3),中心点从A移动到B了，再逆时针旋转angle角度，坐标系变成（x3, y­4）了，这样我们在坐标系(x3, y4)上画刻度值20，我们采用画笔的getTextBounds方法获取文字边框，在边框里面绘制20，之后再按原路的动作反方向返回，这样我们又回到刚开始的坐标系(x2, y2)。我们将这一系列的动作写进一个drawScaleNumber方法。  </p><p><img src="/Ouyang/images/yibiao/16.png" srcset="/Ouyang/img/loading.gif" alt="alt">      </p><p><img src="/Ouyang/images/yibiao/17.png" srcset="/Ouyang/img/loading.gif" alt="alt">  </p><h5><span id="动画"><strong>动画</strong></span></h5><p>​           仪表盘的动画是怎么实现的呢，这里通过属性动画ValueAnimator来实现。通过改变属性值来创造动画。</p><p><img src="/Ouyang/images/yibiao/18.png" srcset="/Ouyang/img/loading.gif" alt="alt">  </p><p>  我们创造了两个ValueAnimator对象，参数mTotalAngle, mMaxNum都是通过公有方法外部传入，第一个ValueAnimator对象的作用是用来做进度圆弧动画的，第二个ValueAnimator对象是用来做中间百分比数字值渐变。首先我们创建一个ofFloat(mCurrentAngle, mTotalAngle)对象，这个属性值范围就是从mCurrentAngle到mTotalAngle，mCurrentAngle默认为0; 通过设置一个时间插值器同时设置监听addUpdateListener(new ValueAnimator.AnimatorUpdateListener())就可以拿到在这个时间插值器里从mCurrentAngle递增到mTotalAngle之中的值。拿到mCurrentAngle后重新绘制UI，这样就达到我们的动画效果。前面介绍的画进度圆弧用的mCurrentAngle就是从这里拿到的。同理，做百分比数字递增动画也是这样做的。</p><p>​       最后我们实现出来的的效果图</p><p><img src="/Ouyang/images/yibiao/19.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android绘制UI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TopK问题之前K个高频元素</title>
    <link href="/Ouyang/2020/04/30/TopK%E9%97%AE%E9%A2%98%E4%B9%8B%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
    <url>/Ouyang/2020/04/30/TopK%E9%97%AE%E9%A2%98%E4%B9%8B%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<p>给定一个非空的整数数组，返回其中出现频率前 K高的元素。</p><p><strong>示例 1:</strong></p><pre><code class="java">输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2]</code></pre><p>提示：</p><p>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。<br>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。<br>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。<br>你可以按任意顺序返回答案。</p><p><strong>解题思路：</strong></p><p>方法一：采用暴露排序法， <strong>使用排序算法对元素按照频率由高到低进行排序</strong>，然后再取前 k个元素，时间复杂度已超过nlogn。</p><p>方法二：hashMap和最小堆</p><ul><li>首选用hashMap存每个数出现的次数，key为当前数，value为该数在数组出现的次数。</li><li>建立一个最小堆，该堆排序是按照value进行升序排序的，我们可以利用java类PriorityQueue，该类默认升序排列，该类介绍可以参看<a href="https://www.cnblogs.com/dxflqm/p/12067265.html，" target="_blank" rel="noopener">https://www.cnblogs.com/dxflqm/p/12067265.html，</a></li><li>如果建堆的时候，堆大小超过了K，我们直接poll()弹出，剩下的就是大小为K的最小堆，即为我们所求。</li></ul><p><img src="/Ouyang/images/acm/1.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p><p>代码如下：</p><pre><code class="java"> class Solution    {        public List&lt;Integer&gt; topKFrequent(int[] nums, int k)        {            // 用hashMap存            HashMap&lt;Integer, Integer&gt; count = new HashMap();            for (int n : nums)            {                count.put(n, count.getOrDefault(n, 0) + 1);            }            // 初始化最小堆，按value值升序排列。            PriorityQueue&lt;Integer&gt; heap =                    new PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; count.get(n1) - count.get(n2));            // 遍历map，构建key，大小为K的最小key堆            for (int n : count.keySet())            {                heap.add(n);                if (heap.size() &gt; k)                {                    heap.poll();                }            }            // 构建我们的结果            List&lt;Integer&gt; top_k = new LinkedList();            while (!heap.isEmpty())            {                top_k.add(0, heap.poll());                return top_k;            }        }    }</code></pre><p>这个步骤需要 O(N) 时间其中 N 是列表中元素个数。</p><p>第二步建立堆，堆中添加一个元素的复杂度是 O(log(k))，要进行 N 次复杂度是 O(N)。</p><p>最后一步是输出结果，复杂度为O(klog(k)</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转字符串</title>
    <link href="/Ouyang/2020/04/30/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/Ouyang/2020/04/30/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p>给定一个字符串，反转怎么反转，要求不开辟额外空间？</p><p><strong>很简单，思路：</strong></p><p>不额外开辟空间，那么就定义中间变量然后 交换就可以了。用最头和最尾交换 那就是0和length-1交换，以此类推就可以推演为i与length-i-1交换。因为整数除法直接舍弃小数，所以单数双数对于交换次数的判断没有影响 是length/2</p><pre><code class="java">public void reverseString(char[] s){  if (s == null || s.length == 0)  {    return;  }  for(int i = 0; i &lt; s.length / 2; i++)  {    char temp = s[i];    s[i] = s[s.length - 1 - i]; // 首尾交换    s[s.length - 1 - i] = temp;  }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大子序和</title>
    <link href="/Ouyang/2020/04/30/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <url>/Ouyang/2020/04/30/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>给定一个整数数组,因为数组中不同的且连续的子序列有不同的和,返回数组中子序列最大的和值</p><p>举例:</p><p>输入: [-2,1,-3,4,-1,2,1,-5,4],</p><p>输出: 6</p><p><strong>解题思路：</strong></p><ul><li><p>sum 为子序列之和，sum &gt;0 则说明结果有增，则sum 保留当前遍历数字</p></li><li><p>如果sum &lt;=0,则说明sum对结果无增益效果，需要舍弃，则sum直接更新为当前遍历数字                 </p></li><li><p>每次比较sum和ans的大小，将最大值置为ans，遍历结束返回结果</p></li><li><p>时间复杂度为O(n)</p></li></ul><p>​    </p><pre><code class="java">class Solution {  public int maxSubArray(int[] nums)  {    if (nums == null || nums.length == 0)    {      return 0;    }    int sum = 0;    int ans = nums[0];    for(int i = 0; i &lt; nums.length; i++)    {      if (sum &gt; 0)      {        sum += nums[i];      }      else      {        sum = nums[i];      }      ans = Math.max(ans, sum);    }    return ans;  }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>赤湾一览</title>
    <link href="/Ouyang/2020/04/24/%E8%B5%A4%E6%B9%BE%E4%B8%80%E8%A7%88/"/>
    <url>/Ouyang/2020/04/24/%E8%B5%A4%E6%B9%BE%E4%B8%80%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<p>上一次是去小南山还是三年前，当时和CFG两人从不不知名的小道一路狂爬到山顶，前阵子再去重温小南山，真的是大改，爬楼也不用那么陡坡了，直接图！后期：LR.</p><p> <img src="/Ouyang/images/life/1.jpeg" srcset="/Ouyang/img/loading.gif" alt="alt"></p><p> <img src="/Ouyang/images/life/2.jpeg" srcset="/Ouyang/img/loading.gif" alt="alt"></p><p> <img src="/Ouyang/images/life/3.jpeg" srcset="/Ouyang/img/loading.gif" alt="alt"></p><p> <img src="/Ouyang/images/life/4.jpeg" srcset="/Ouyang/img/loading.gif" alt="alt"></p>]]></content>
    
    
    <categories>
      
      <category>摄影</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode盛最多水的容器</title>
    <link href="/Ouyang/2020/04/24/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <url>/Ouyang/2020/04/24/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>给你 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p><p><img src="/Ouyang/images/acm/water.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p>怎么解呢？没错，<strong>“双指针”法！</strong></p><p>​        在初始时，比如第一个指针在1位置，第二个在7位置，左右指针分别指向数组的左右两端，它们可以容纳的水量为 min(1, 7) * 8 = 8min(1,7)∗8=8。此时我们需要移动一个指针。移动哪一个呢？直觉告诉我们，应该移动对应数字较小的那个指针（即此时的左指针）。这是因为，由于容纳的水量是由</p><p>​                                                    <strong>两个指针指向的数字中较小值 * 指针之间的距离</strong></p><p>决定的。如果我们移动数字较大的那个指针，那么前者「两个指针指向的数字中较小值」不会增加，后者「指针之间的距离」会减小，那么这个乘积会减小。反之，右指针如果小于左指针，则右指针往左边移动，因此，我们移动数字较大的那个指针是不合理的。因此，我们移动 数字较小的那个指针。代码如下：</p><pre><code class="java">class Solution {    public int maxArea(int[] height) {        int l = 0;        int r = height.length - 1;        int result = 0;        while(l &lt;= r)         {            int area = Math.min(height[l], height[r]) * (r - l);                result = Math.max(result, area);            if (height[l] &lt; height[r])            {                l++;            }            else             {                r--;            }        }        return result;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android插件化原理研究</title>
    <link href="/Ouyang/2020/04/17/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%8E%9F%E7%90%86%E7%A0%94%E7%A9%B6/"/>
    <url>/Ouyang/2020/04/17/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%8E%9F%E7%90%86%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<p>Todo,下个月的task！</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android智能盯盘绘制View</title>
    <link href="/Ouyang/2020/04/16/Android%E6%99%BA%E8%83%BD%E7%9B%AF%E7%9B%98%E7%BB%98%E5%88%B6View/"/>
    <url>/Ouyang/2020/04/16/Android%E6%99%BA%E8%83%BD%E7%9B%AF%E7%9B%98%E7%BB%98%E5%88%B6View/</url>
    
    <content type="html"><![CDATA[<p>​    智能盯盘主要涉及两个自绘View，一个圆环，一个仪表盘，都是带圆的，用到的关键方法都是画布的Canvas.drawArc()方法。自绘View无非就是继承View复写View一些方法，得到我们自己想要的View，那你真的了解View的生命周期吗？我们自绘View用的最多的一个方法就是复写onDraw(Canvas canvas)方法，利用强大的Canvas以及画笔Paint来搞事。</p><ul><li><h5><span id="view的关键生命周期流程图"><strong>View的关键生命周期流程图</strong></span></h5></li></ul><p><img src="/Ouyang/images/pan/1.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p><ol><li><p>首先是构造方法，Contructor</p></li><li><p>onFinishInflate，这个布局通过LayoutInflater进行填充的时候会走到这个方法。</p></li><li><p>onAttachedToWindow,当前View跟它对应的Window已经绑定。</p></li><li><p>onMeasure，开始测量，调用时间，当控件的父元素放置该控件时候，用于告诉父元素该控件的大小，父元素问该控件需要多大空间，该控件复写onMeasure(int widthMeasureSpec, int heightMeasureSpec)方法，调用setMeasuredDimension(int w, int h)告诉父元素具体大小。该控件怎么通过父元素的widthMeasureSpec, heightMeasureSpec告诉父元素具体大小呢？强大的MeasureSepc类，封装了父布局传递给子布局的布局要求，每个MeasureSpec代表了一组宽度和高度的要求，MeasureSpec由size和mode组成。Size可以通过 MeasureSpec. getSize(int measureSpec)拿到，mode通过MeasureSpec.getMode(int measureSpec)拿到，mode主要有以下三种类型：<br>1）MeasureSpec.EXACTLY<br>表示当layout_为match_parent或者具体的值时，mode代表具体精确的值。<br>2）MeasureSpec.AT_MOST<br>表示当layout_为wrap_content，能获得的最大尺寸，一般我们都会在自绘View设置一个默认最小宽度的minSize，我们通过取最小值。<br>3）MeasureSpec.UNSPECIFIED<br>表示当无法确定尺寸的时候，这个时候会用默认的最小值。一般代码都是如下这样设置：<br><img src="/Ouyang/images/pan/2.png" srcset="/Ouyang/img/loading.gif" alt="alt"><br><img src="/Ouyang/images/pan/3.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p></li><li><p>onSizeChanged, 测量之后会回调这个方法，当尺寸变化后会调用，一般都是第一次测量后会调用，后面再测量，若尺寸没有变化就不会再去调用，我们获取的宽高基本在这个方法获取。<br><img src="/Ouyang/images/pan/4.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p></li><li><p>onLayout，测量的时候进行布局，确定子View的位置。</p></li><li><p>onDraw, 确定完宽高和位置，利用强大的画布Canvas和画笔Paint绘制我们所需要的View。</p></li><li><p>onDetachedFromWindow，退出当前Activity后会走到这个方法。</p><p>我们通过Log打印也可以看到View的大概生命周期流程如下：<br><img src="/Ouyang/images/pan/24.png" srcset="/Ouyang/img/loading.gif" alt="alt"><br>一般我们自绘制view复写onMeasure, onSizeChanged, onDraw 这三个方法就可以了。</p></li></ol><ul><li><h5><span id="圆环自绘view">圆环自绘View</span></h5><p>我们主要看下onDraw方法是怎么画的。</p></li></ul><ol><li><p>首先我们画之前，需要将数据源设置进来，我们创建了个这样的数据model，包含数值，颜色；当然以后需要扩展，比如需要画标签，线条啥的，可以往这个model里面添加对应的属性进来。<br><img src="/Ouyang/images/pan/6.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p></li><li><p>在onDraw 方法里面，为了我们坐标的更好的对称换算，将默认的坐标系原点平移到当前画布的中心位置。<br><img src="/Ouyang/images/pan/7.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p></li><li><p>算出传入进来的所有数据model的总数值 total.</p></li><li><p>循环画每一段圆环。我们用到的函数就是画布的drawArc方法，canvas.drawArc(RectF oval, float startAngle, float sweepAngle, Boolean useCenter, Paint paint)；oval代表圆环的外切矩形，startAngle代表画圆环的起始位置角度，sweepAngle代表当前圆环扫过的角度，sweepAngle大于0表示顺时针扫，小于0表示逆时针扫；useCenter表示是否包含中心原点连线，如果为true，画出的圆环将会是个衔接原点的扇形饼状，所以我们如果画饼状图，只要调成true就可以了；false就表示画圆环了。Paint表示画笔。<br>1）根据当前数值和总数值total，先算当前要画的这段圆环占整个圆环的角度，即sweepAngle.<br>2）我们用了个变量startAngle来控制每一段圆环的起始位置角度，默认从0度开始画圆环，当然可以根据实际需要调整。大概代码如下，很简单。<br><img src="/Ouyang/images/pan/8.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p></li><li><p>可以看我画的草图如下：<br><img src="/Ouyang/images/pan/9.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p></li><li><p>注意，圆环真正的半径是mRadius – mPaint.getStrokeWidth()*0.5f，即大圆的半径减去画笔粗度的一半。参数rectF也为这个圆环半径的外切矩形。</p></li><li><p>测试结果：<br><img src="/Ouyang/images/pan/10.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p></li></ol><ol start="8"><li>如果需要往每段圆环上画折线以及标签，可以在每一段循环画圆环后补充相应的代码，有兴趣的可以去看下被注释掉的“功能拓展部分”这段代码，里面涉及到一些数学的三角函数的坐标换算。在分支smart_stare类TransactionActivityRingChartView里面可以了解。<br>测试结果：<br><img src="/Ouyang/images/pan/11.png" srcset="/Ouyang/img/loading.gif" alt="alt"></li></ol><ul><li><h5><span id="仪表盘自绘view">仪表盘自绘View</span></h5></li></ul><ol><li><p>首先将坐标系原点移动到距离原来中心3/4个距离的地方，因为底部要画标签，所以这里空出点距离给标签，canvas.translate(mWidth / 2, mHeight *3 / 4)。<br><img src="/Ouyang/images/pan/12.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p></li><li><p>画半圆弧。原理类似。这里由于视觉上半圆弧有渐变色，需要给画笔设置渐变色shader, 三种色值分别位于九点钟、三点钟和12点钟方向，对应的postions为{0.5f, 0.75f, 1f}，代码如下：<br><img src="/Ouyang/images/pan/13.png" srcset="/Ouyang/img/loading.gif" alt="alt"><br><img src="/Ouyang/images/pan/14.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p></li><li><p>画圆弧刻度线，采用画布旋转的方法，结合画布的保存与恢复方法可以很方便的画出来。视觉稿刻度间距总共分为60等分，在0，10，20，30，40，50，60对画笔以及刻度长度值做一些特殊的属性值设置。<br><img src="/Ouyang/images/pan/15.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p></li><li><p>画文字标签，这里给大家普及下很key的一个参数，baseLine, 即基准Y坐标。canvas.drawText(String text, float x, float y, Paint paint), x指的是文字的起始坐标，这里的y指的是文字标签基准线的baseLine坐标.<br><img src="/Ouyang/images/pan/16.png" srcset="/Ouyang/img/loading.gif" alt="alt"><br>如上图标注，通常用FontMetrics的top, bottom变量就可以算出基准线的坐标。top是相对于BaseLine偏移量，因为它在基准线上面，所以为负数，bottom是相对于BaseLine偏移量，为正数。通常我们计算文字的高度就是bottom – top;<br><img src="/Ouyang/images/pan/17.png" srcset="/Ouyang/img/loading.gif" alt="alt"><br>baseLine的坐标 = 1/2 * getFontHeight() + getHeight() / 2 – FontMetrics.bottom.<br>画文字标签的主要代码如下：<br><img src="/Ouyang/images/pan/18.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p></li></ol><ol start="5"><li><p>画指针，通过canvas.drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint)；bitmap为图片资源对象，src表示对图片进行裁剪，若为null表示显示整个图片;dst是图片在Canvas画布中显示的区域，src会被自动缩放/平移以适应它。我们通过画布的保存，恢复以及旋转方法，并用变量mStartAngle控制坐标系的旋转角度，默认mStartAngle = 0,即坐标系不旋转，从90度开始画，而且这个变量是通过动画类ValueAnimator.getAnimatedValue实时拿到的，这样就可以实时看到指针在旋转动起来。<br>1）首先我们要将drawable图片资源转换成bitmap<br><img src="/Ouyang/images/pan/19.png" srcset="/Ouyang/img/loading.gif" alt="alt"><br>2）通过画布的保存，画布的旋转，画布的恢复方法画指针<br><img src="/Ouyang/images/pan/20.png" srcset="/Ouyang/img/loading.gif" alt="alt"><br>草图大概如下：<br><img src="/Ouyang/images/pan/21.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p></li><li><p>通过动画类ValueAnimator执行动画，我们根据外部传入的数值算出终止角度mTotalAngle，传入 ValueAnimator.ofFloat(mStartAngle, mTotalAngle);通过动画接口回调，函数getAnimatedValue拿到实时值mStartAngle，然后重新绘，得到我们想要的动画。代码如下：<br><img src="/Ouyang/images/pan/22.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p></li><li><p>测试结果：<br><img src="/Ouyang/images/pan/23.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android绘制UI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见Hexo命令</title>
    <link href="/Ouyang/2020/03/27/%E5%B8%B8%E8%A7%81Hexo%E5%91%BD%E4%BB%A4/"/>
    <url>/Ouyang/2020/03/27/%E5%B8%B8%E8%A7%81Hexo%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h5><span id="常见命令">常见命令</span></h5><p>hexo new “postName” #新建文档</p><p>hexo generate #生成静态页面</p><p>hexo server #本地预览端口（默认端口4000，输入<a href="https://link.jianshu.com/?t=https://localhost:4000" target="_blank" rel="noopener">https://localhost:4000</a> 访问</p><p>hexo deploy #部署到gitHub</p><p>hexo help #查看帮助</p><p>hexo version #查看hexo版本</p><h5><span id="组合命令">组合命令</span></h5><p>hexo s -g #生成本地预览</p><p>hexo d -g #生成并上传</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Binder机制初探</title>
    <link href="/Ouyang/2020/03/27/Binder%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/"/>
    <url>/Ouyang/2020/03/27/Binder%E6%9C%BA%E5%88%B6%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<p>整个文章目录如下图：</p><p><img src="/Ouyang/images/binder/ha.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p><h4><span id="1binder概述"><strong>1.Binder概述</strong></span></h4><ul><li><ul><li><p>Binder中文名“粘合剂”，粘合了两个不同的进程。那Binder到底是什么呢？</p><ul><li>从机制角度来说，Binder是一种Android实现跨进程通信（IPC）的方式</li><li>从组成结构来说，Binder是一种虚拟的物理设备驱动</li><li>从代码实现角度来说，Binder是一个类，实现了IBinder接口</li></ul></li><li><p>Android 系统是基于 Linux 内核的，Linux 已经提供了管道、消息队列、共享内存和 Socket 等 IPC 机制。那为什么 Android 还要提供 Binder 来实现 IPC 呢？主要是基于<strong>性能</strong>、<strong>稳定性</strong>和<strong>安全性</strong>几方面的原因。</p></li></ul></li></ul><h5><span id="性能"><strong>性能</strong></span></h5><p>​    从进程A将数据拷贝到进程B，传统的Socket主要用在跨网络的进程间通信和本机上进程间的低速通信，消息队列和管道采用存储-转发的方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存无需拷贝，但难以控制。Binder仅需要一次数据拷贝，性能上仅次于共享内存。</p><table><thead><tr><th>IPC方式</th><th>数据拷贝次数</th></tr></thead><tbody><tr><td>共享内存</td><td>0</td></tr><tr><td>Binder</td><td>1</td></tr><tr><td>Socket/管道/消息队列</td><td>2</td></tr></tbody></table><h5><span id="稳定性"><strong>稳定性</strong></span></h5><p>​    Binder 基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。</p><h5><span id="安全性"><strong>安全性</strong></span></h5><p>​    首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。</p><p>​    基于以上选择Binder的优势：</p><table><thead><tr><th>优势</th><th>描述</th></tr></thead><tbody><tr><td>性能</td><td>一次数据拷贝，性能上仅次于共享内存</td></tr><tr><td>稳定性</td><td>基于 C/S 架构，职责明确、架构清晰，因此稳定性好</td></tr><tr><td>安全性</td><td>为每个 APP 分配 UID，进程的 UID 是鉴别进程身份的重要标志</td></tr></tbody></table><h4><span id="2-传统linux进程通信原理"><strong>2. 传统Linux进程通信原理</strong></span></h4><h5><span id="进程隔离">进程隔离</span></h5><ul><li>操作系统中，进程与进程间内存是不共享的。两个进程就像两个平行的世界，A 进程没法直接访问 B 进程的数据，这就是进程隔离的通俗解释。A 进程和 B 进程之间要进行数据交互就得采用特殊的通信机制：进程间通信（IPC）</li></ul><h5><span id="进程空间划分">进程空间划分</span></h5><ul><li><p>一个进程空间分为用户空间（User Space）和内核空间（Kernel Space）</p></li><li><p>进程间的用户空间数据不可共享</p></li><li><p>进程间的内核空间数据可共享</p></li><li><p>进程内用户空间与内核空间交互需要通过系统调用</p></li><li><p>系统调用</p></li></ul><pre><code>copy_from_user() //将数据从用户空间拷贝到内核空间copy_to_user() //将数据从内核空间拷贝到用户空间</code></pre><p><img src="/Ouyang/images/binder/1.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p><h5><span id="linux传统ipc通信">Linux传统IPC通信</span></h5><ul><li>传统的 IPC 方式中，进程之间是如何实现通信的？消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 copy_from_user() 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copy_to_user() 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。如下图：</li></ul><p><img src="/Ouyang/images/binder/2.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p><ul><li><ul><li><ul><li>可以看到传统的IPC通信需要两次数据拷贝，性能低下</li><li>接收数据的缓存需要接收方提供，但接收方不知道缓存有多大，一般尽量开辟一个很大的缓存空间，有点浪费资源。</li></ul></li></ul></li></ul><h4><span id="3-binder跨进程通信原理"><strong>3. Binder跨进程通信原理</strong></span></h4><h5><span id="内存映射">内存映射</span></h5><ul><li>Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。</li><li>简单示意图如下：<ul><li>假设进程1、2的虚拟内存区域同时映射到同1个共享对象；</li><li>当进程1对其虚拟内存区域进行写操作时，也会映射到进程2中的虚拟内存区域。</li></ul></li></ul><p><img src="/Ouyang/images/binder/3.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p><h5><span id="实现过程">实现过程</span></h5><ul><li>调用系统下的系统调用函数：mmap()</li><li>该函数的作用是创建虚拟内存区域 + 与共享对象建立映射关系。</li><li>函数原型</li></ul><pre><code>/**  * 函数原型  */void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);/**  * 具体使用（用户进程调用mmap（））  * 下述代码开辟了一片大小 = MAP_SIZE的接收缓存区 &amp; 关联到共享对象中（即建立映射）  */  mmap(NULL, MAP_SIZE, PROT_READ, MAP_PRIVATE, fd, 0);</code></pre><ul><li><ul><li><ul><li><ul><li><ul><li>步骤1：创建虚拟内存区域<br>步骤2：实现地址映射关系，即：进程的虚拟地址空间 -&gt;&gt; 共享对象</li></ul></li></ul></li></ul><p>Binder驱动 </p><ul><li>在 Android 系统中，运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块。</li><li>综合概述如下图所示</li></ul></li></ul></li></ul><p><img src="/Ouyang/images/binder/4.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p><h5><span id="binder通信机制模型">Binder通信机制模型</span></h5><ul><li>基于C/S模式<ul><li>Client进程：使用服务的进程</li><li>Server进程：提供服务的进程</li><li>ServiceManager进程：管理Service注册与查询</li><li>Binder驱动：一种虚拟设备，连接Client进程、Server进程和ServiceManager进程的桥梁；通过内存映射传递进程间数据。</li></ul></li></ul><p><img src="/Ouyang/images/binder/5.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p><h5><span id="binder代理模式">Binder代理模式</span></h5><ul><li>Client进程想要 Server进程中某个对象（Object）是如何实现的呢？毕竟它们分属不同的进程，Client进程没法直接使用 Server进程中的 Object。</li><li>Client进程请求Server进程Object对象时候，Binder驱动会对数据做一层转换，返回一个代理对象ProxyObject，这个ProxyObject具有和Object对象一样的方法，不具备Server进程中的Object对象那些方法的能力，但请求的时候只需要把请求参数交给驱动即可。</li><li>当 Binder 驱动接收到 Client 进程的消息后，发现这是个 ProxyObject 就去查询自己维护的表单，一查发现这是 Server 进程 Object 的代理对象。于是就会去通知Server进程调用Object 的方法，并要求Server进程把返回结果发给自己。当驱动拿到Server进程的返回结果后就会转发给 Client进程。</li><li>示意图如下：</li></ul><p><img src="/Ouyang/images/binder/6.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p><h5><span id="binder-ipc通信过程">Binder IPC通信过程</span></h5><ul><li>Binder 驱动在内核空间创建一个<strong>数据接收缓存区</strong></li><li>接着在内核空间开辟一块<strong>内核缓存区</strong>，建立<strong>内核缓存区</strong>和<strong>内核中数据接收缓存区</strong>之间的映射关系，以及<strong>内核中数据接收缓存区</strong>和<strong>接收进程用户空间地址</strong>的映射关系；</li><li>发送方进程通过系统调用 copy_from_user() 将数据 copy 到内核中的<strong>内核缓存区</strong>，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</li><li>如下图所示：</li></ul><p><img src="/Ouyang/images/binder/7.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p><h4><span id="4-binder机制在android实践aidl"><strong>4. Binder机制在Android实践(AIDL)</strong></span></h4><p>这里Server进程是开启了一个继承Service的类，来模拟进程间通信的。</p><h5><span id="注册服务">注册服务</span></h5><ul><li>这里我们用AS工具新建一个AIDL文件，IBookMananger.aidl，接口里面定义一个addBook()、getBookList()方法，其中Book类实现了Parcelable接口。</li></ul><pre><code>interface IBookMananger {    /**     * Demonstrates some basic types that you can use as parameters     * and return values in AIDL.     */    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,            double aDouble, String aString);            void addBook(inout Book book);            List&lt;Book&gt; getBookList();}</code></pre><ul><li><ul><li>创建一个和Book同名的aidl文件，Book.aidl</li></ul></li></ul><pre><code>// Book.aidlpackage com.example.aidldemo.bean;parcelable Book;</code></pre><ul><li><ul><li>然后Make Project ，SDK为自动为我们生成对应的IBookManager类，目录在generatedJava</li></ul></li></ul><p><img src="/Ouyang/images/binder/8.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p><h5><span id="获取服务">获取服务</span></h5><ul><li>Client通过binderService绑定Server进程注册的Server进程</li><li>调用Server进程的onBind()得到创建的Binder对象的代理对象Proxy</li><li>Client进程通过调用onServiceConnected()获得Server进程创建的代理对象Proxy。</li></ul><pre><code>    private ServiceConnection mServiceConnection = new ServiceConnection()    {        @Override        public void onServiceConnected(ComponentName name, IBinder binder)        {                          //此处返回的是一个代理对象Proxy            //通过服务端onBind方法返回的binder对象得到IBookManager的实例，得到实例就可以调用它的方法了            mIBookMananger = IBookMananger.Stub.asInterface(binder);        }        @Override        public void onServiceDisconnected(ComponentName name)        {            mIBookMananger = null;        }    };    public static com.example.aidldemo.IBookMananger asInterface(android.os.IBinder obj)    {        if ((obj == null))        {            return null;        }        android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);                //如果是同一个进程调用则返回IBookManager对象，否则跨进程调用则返回Proxy对象，即                   Binder类的代理对象。        if (((iin != null) &amp;&amp; (iin instanceof com.example.aidldemo.IBookMananger)))        {            return ((com.example.aidldemo.IBookMananger) iin);        }        return new com.example.aidldemo.IBookMananger.Stub.Proxy(obj);    }</code></pre><h5><span id="使用服务">使用服务</span></h5><ul><li>Client进程 将参数（Book对象）发送到Server进程</li><li>Server进程根据Client进程要求调用目标方法（即addBook函数）</li><li>Server进程 将目标方法的结果（即加法后的结果）返回给Client进程</li></ul><pre><code>    //1. Client进程 将需要传送的数据写入到Parcel对象中    @Override public void addBook(com.example.aidldemo.bean.Book book) throws android.os.RemoteException    {        android.os.Parcel _data = android.os.Parcel.obtain();        android.os.Parcel _reply = android.os.Parcel.obtain();        try {            _data.writeInterfaceToken(DESCRIPTOR);            if ((book!=null)) {                _data.writeInt(1);                book.writeToParcel(_data, 0);            }            else {                _data.writeInt(0);            }    // 2. 通过 调用代理对象的transact（）将上述数据发送到Binder驱动，并且以_reply结果返回给Client进程            mRemote.transact(IBookMananger.Stub.TRANSACTION_addBook, _data, _reply, 0);            _reply.readException();            if ((0!=_reply.readInt())) {                book.readFromParcel(_reply);            }        }        finally {            _reply.recycle();            _data.recycle();        }    }    // 注：在发送数据后，Client进程的该线程会暂时被挂起       // 所以不要在Server进程执行的耗时操作            @Override            public java.util.List&lt;com.example.aidldemo.bean.Book&gt; getBookList() throws android.os.RemoteException            {                android.os.Parcel _data = android.os.Parcel.obtain();                android.os.Parcel _reply = android.os.Parcel.obtain();                java.util.List&lt;com.example.aidldemo.bean.Book&gt; _result;                try                {                    // 1. Binder驱动根据代理对象沿原路将结果返回并通知Client进程获取返回结果，client进程会拿到这个result展示在UI                    // 2. 通过代理对象 接收结果（之前被挂起的线程被唤醒）                    _data.writeInterfaceToken(DESCRIPTOR);                    mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0);                    _reply.readException();                    _result = _reply.createTypedArrayList(com.example.aidldemo.bean.Book.CREATOR);                }                finally                {                    _reply.recycle();                    _data.recycle();                }                return _result;            }</code></pre><p>​    通过addBook将数据发送给Server进程进行计算，并将结果返回给Client端，toast添加book的数量。Demo示意图如下：</p><p>​    <img src="/Ouyang/images/binder/9.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p><p>总结，整个时序逻辑如下：</p><p><img src="/Ouyang/images/binder/10.png" srcset="/Ouyang/img/loading.gif" alt="alt"></p><p>PS：受水平有限，只是对Binder一个很浅的初步认识总结。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android屏幕适配方案</title>
    <link href="/Ouyang/2020/03/27/Android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88/"/>
    <url>/Ouyang/2020/03/27/Android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h5><span id="布局适配">布局适配</span></h5><ul><li>使用RelativeLayout，即使屏幕大小改变，但控件的相对位置不变。</li><li>使用限定符，对不同设备大小屏幕，可以使用尺寸限定符（layout-large）创建布局文件，大号设备布局用layout-large布局，默认用layout；还可以用最小宽度(Smallest-width)限定符</li></ul><h5><span id="布局组件适配">布局组件适配</span></h5><ul><li>使用wrap_content、 match_parent和weight来控制视图组件的宽度和高度</li><li>还有可以设置minHeight，minWidth</li></ul><h5><span id="图片资源适配">图片资源适配</span></h5><ul><li>使用.9图片资源，自动拉伸位图。.9.png，会根据控件的大小自动拉伸你想要的部分。</li></ul><h5><span id="布局控件适配">布局控件适配</span></h5><ul><li>使用密度无关像素dp来指定控件大小，density-independent pixel 可以保证不同屏幕像素密度设备显示相同的效果.</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World 欢迎来到欧阳程序猿的工作室</title>
    <link href="/Ouyang/2020/03/26/hello-world/"/>
    <url>/Ouyang/2020/03/26/hello-world/</url>
    
    <content type="html"><![CDATA[<h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3><span id="run-server">Run server</span></h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3><span id="generate-static-files">Generate static files</span></h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>欧阳</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
